From 12c247d129ecfed7fa0b5817a0777dc383329bdd Mon Sep 17 00:00:00 2001
From: Olivier Masse <olivier.masse@nxp.com>
Date: Thu, 10 Oct 2019 10:27:41 +0200
Subject: [PATCH 45/51] MMIOT-192 : hantro decoder: Add support for imx8mq

---
 arch/arm64/configs/defconfig                 |   1 +
 drivers/mxc/Kconfig                          |   1 +
 drivers/mxc/Makefile                         |   1 +
 drivers/mxc/hantro/Makefile                  |   1 +
 drivers/mxc/hantro/hantrodec.c               | 322 +++++++++++++++++++++------
 drivers/mxc/hantro_845/Kconfig               |   7 -
 drivers/mxc/hantro_845/Makefile              |   2 +-
 drivers/mxc/hantro_845/hantrodec_845s.c      |  51 ++---
 drivers/mxc/hantro_845/hantrodec_secure.c    | 262 ----------------------
 drivers/mxc/hantro_845/hantrodec_secure.h    |  44 ----
 drivers/mxc/hantro_secure/Kconfig            |  15 ++
 drivers/mxc/hantro_secure/Makefile           |   6 +
 drivers/mxc/hantro_secure/hantrodec_secure.c | 262 ++++++++++++++++++++++
 drivers/mxc/hantro_secure/hantrodec_secure.h |  44 ++++
 14 files changed, 614 insertions(+), 405 deletions(-)
 delete mode 100644 drivers/mxc/hantro_845/hantrodec_secure.c
 delete mode 100644 drivers/mxc/hantro_845/hantrodec_secure.h
 create mode 100644 drivers/mxc/hantro_secure/Kconfig
 create mode 100644 drivers/mxc/hantro_secure/Makefile
 create mode 100644 drivers/mxc/hantro_secure/hantrodec_secure.c
 create mode 100644 drivers/mxc/hantro_secure/hantrodec_secure.h

diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 10008cd..25d33e8 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -639,6 +639,7 @@ CONFIG_MMC_SDHCI_XENON=y
 CONFIG_MXC_MLB150=y
 CONFIG_MXC_SIM=y
 CONFIG_MXC_EMVSIM=y
+CONFIG_MXC_HANTRO_SECURE=y
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
 CONFIG_LEDS_GPIO=y
diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index a011dcd..bf089ee 100755
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -22,6 +22,7 @@ source "drivers/mxc/sim/Kconfig"
 if ARCH_MXC_ARM64
 source "drivers/mxc/hantro_845/Kconfig"
 source "drivers/mxc/hantro_845_h1/Kconfig"
+source "drivers/mxc/hantro_secure/Kconfig"
 source "drivers/mxc/vpu_legacy/Kconfig"
 source "drivers/mxc/vpu_malone/Kconfig"
 source "drivers/mxc/vpu_windsor/Kconfig"
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index 72b6b64..fa4897c 100755
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_MXC_MIPI_CSI2) += mipi/
 obj-$(CONFIG_MXC_HANTRO) += hantro/
 obj-$(CONFIG_MXC_HANTRO_845) += hantro_845/
 obj-$(CONFIG_MXC_HANTRO_845_H1) += hantro_845_h1/
+obj-$(CONFIG_MXC_HANTRO_SECURE) += hantro_secure/
 obj-$(CONFIG_MXC_VPU_LEGACY) += vpu_legacy/
 obj-$(CONFIG_MX8_HDP)	+= hdp/
 obj-$(CONFIG_IMX_HDP_CEC)	+= hdp-cec/
diff --git a/drivers/mxc/hantro/Makefile b/drivers/mxc/hantro/Makefile
index 3673ac2..24443d0 100755
--- a/drivers/mxc/hantro/Makefile
+++ b/drivers/mxc/hantro/Makefile
@@ -3,6 +3,7 @@
 #
 
 ccflags-y += -I$(PWD)/./dwl
+ccflags-$(CONFIG_MXC_HANTRO_SECURE) += -Idrivers/mxc/hantro_secure
 
 obj-$(CONFIG_MXC_HANTRO) += hantrodec.o
 
diff --git a/drivers/mxc/hantro/hantrodec.c b/drivers/mxc/hantro/hantrodec.c
index f93a16e..4e8a59a 100755
--- a/drivers/mxc/hantro/hantrodec.c
+++ b/drivers/mxc/hantro/hantrodec.c
@@ -49,6 +49,12 @@
 #include <linux/clk.h>
 #include <linux/busfreq-imx.h>
 
+#include <linux/delay.h>
+
+#ifdef CONFIG_MXC_HANTRO_SECURE
+#include <hantrodec_secure.h>
+#endif
+
 #ifdef CONFIG_DEVICE_THERMAL
 #include <linux/device_cooling.h>
 #define HANTRO_REG_THERMAL_NOTIFIER(a) register_devfreq_cooling_notifier(a)
@@ -163,6 +169,11 @@ static int hantrodec_major; /* dynamic allocation */
 
 /* here's all the must remember stuff */
 typedef struct {
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	struct tee_context *ctx[HXDEC_MAX_CORES];
+ 	uint32_t session[HXDEC_MAX_CORES];
+	struct tee_shm* shm[HXDEC_MAX_CORES];
+#endif
 	char *buffer;
 	unsigned int iosize[HXDEC_MAX_CORES];
 	volatile u8 *hwregs[HXDEC_MAX_CORES];
@@ -184,13 +195,15 @@ static void ResetAsic(hantrodec_t *dev);
 static void dump_regs(hantrodec_t *dev);
 #endif
 
-/* IRQ handler */
-static irqreturn_t hantrodec_isr(int irq, void *dev_id);
-
 static u32 dec_regs[HXDEC_MAX_CORES][DEC_IO_SIZE_MAX/4];
 struct semaphore dec_core_sem;
 struct semaphore pp_core_sem;
 
+#ifndef CONFIG_MXC_HANTRO_SECURE
+/* IRQ handler */
+static irqreturn_t hantrodec_isr(int irq, void *dev_id);
+#endif
+
 static int dec_irq;
 static int pp_irq;
 
@@ -282,17 +295,40 @@ static int hantro_clk_disable(struct device *dev)
 
 static int hantro_ctrlblk_reset(struct device *dev)
 {
-	volatile u8 *iobase;
-
 	//config G1/G2
 	hantro_clk_enable(dev);
-	iobase = (volatile u8 *)ioremap_nocache(BLK_CTL_BASE, 0x10000);
-	iowrite32(0x3, iobase);  //VPUMIX G1/G2 block soft reset  control
-	iowrite32(0x3, iobase+4); //VPUMIX G1/G2 block clock enable control
-	iowrite32(0xFFFFFFFF, iobase + 0x8); // all G1 fuse dec enable
-	iowrite32(0xFFFFFFFF, iobase + 0xC); // all G1 fuse pp enable
-	iowrite32(0xFFFFFFFF, iobase + 0x10); // all G2 fuse dec enable
-	iounmap(iobase);
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	struct tee_context *ctx = NULL;
+	uint32_t session = 0;
+
+	ctx = hantro_secure_open_context();
+	if (ctx)
+		session = hantro_secure_open(ctx,0xFFFFFFFF);
+
+	if (session)
+	{
+		hantro_secure_regs_write(ctx,session, 0, 0x3);  //VPUMIX G1/G2 block soft reset  control
+		hantro_secure_regs_write(ctx,session, 0x4, 0x3);  //VPUMIX G1/G2 block clock enable control
+
+		hantro_secure_regs_write(ctx,session, 0x8, 0xFFFFFFFF); // all G1 fuse dec enable
+		hantro_secure_regs_write(ctx,session, 0xC, 0xFFFFFFFF);  // all G1 fuse pp enable
+		hantro_secure_regs_write(ctx,session, 0x10, 0xFFFFFFFF);  // all G2 fuse dec enable
+		tee_client_close_session(ctx,session);
+		tee_client_close_context(ctx);
+	}
+	else
+#endif
+	{
+		volatile u8 *iobase;
+
+		iobase = (volatile u8 *)ioremap_nocache(BLK_CTL_BASE, 0x10000);
+		iowrite32(0x3, iobase);  //VPUMIX G1/G2 block soft reset  control
+		iowrite32(0x3, iobase+4); //VPUMIX G1/G2 block clock enable control
+		iowrite32(0xFFFFFFFF, iobase + 0x8); // all G1 fuse dec enable
+		iowrite32(0xFFFFFFFF, iobase + 0xC); // all G1 fuse pp enable
+		iowrite32(0xFFFFFFFF, iobase + 0x10); // all G2 fuse dec enable
+		iounmap(iobase);
+	}
 	hantro_clk_disable(dev);
 	return 0;
 }
@@ -348,6 +384,36 @@ static struct notifier_block hantro_thermal_hot_notifier = {
 };
 #endif  //CONFIG_DEVICE_THERMAL
 
+static void hantro_hwregs_write(hantrodec_t *dev,
+		       uint32_t Core, uint32_t offset, uint32_t value)
+{
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	if (dev->session[Core])
+	{
+		hantro_secure_regs_write(dev->ctx[Core],dev->session[Core],offset,value);
+	}
+	else
+#endif
+	{
+		iowrite32(value, dev->hwregs[Core] + offset);
+	}
+}
+
+static uint32_t hantro_hwregs_read(hantrodec_t *dev,
+		       uint32_t Core, uint32_t offset)
+{
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	if (dev->session[Core])
+	{
+		return hantro_secure_regs_read(dev->ctx[Core],dev->session[Core],offset);
+	}
+	else
+#endif
+	{
+		return ioread32(dev->hwregs[Core] + offset);
+	}
+}
+
 static void ReadCoreConfig(hantrodec_t *dev)
 {
 	int c;
@@ -358,7 +424,7 @@ static void ReadCoreConfig(hantrodec_t *dev)
 	for (c = 0; c < dev->cores; c++) {
 		/* Decoder configuration */
 		if (IS_G1(dev->hw_id[c])) {
-			reg = ioread32(dev->hwregs[c] + HANTRODEC_SYNTH_CFG * 4);
+			reg = hantro_hwregs_read(dev,c,HANTRODEC_SYNTH_CFG * 4);
 
 			tmp = (reg >> DWL_H264_E) & 0x3U;
 			if (tmp)
@@ -390,7 +456,7 @@ static void ReadCoreConfig(hantrodec_t *dev)
 				pr_debug("hantrodec: Core[%d] has VP6\n", c);
 			cfg[c] |= tmp ? 1 << DWL_CLIENT_TYPE_VP6_DEC : 0;
 
-			reg = ioread32(dev->hwregs[c] + HANTRODEC_SYNTH_CFG_2 * 4);
+			reg = hantro_hwregs_read(dev,c,HANTRODEC_SYNTH_CFG_2 * 4);
 
 			/* VP7 and WEBP is part of VP8 */
 			mask =  (1 << DWL_VP8_E) | (1 << DWL_VP7_E) | (1 << DWL_WEBP_E);
@@ -414,9 +480,9 @@ static void ReadCoreConfig(hantrodec_t *dev)
 			cfg[c] |= tmp ? 1 << DWL_CLIENT_TYPE_RV_DEC : 0;
 
 			/* Post-processor configuration */
-			//reg = ioread32(dev->hwregs[c] + HANTROPP_SYNTH_CFG * 4);
+			//reg = hantro_hwregs_read(dev,c,HANTROPP_SYNTH_CFG * 4);
 		} else {
-			reg = ioread32(dev->hwregs[c] + HANTRODEC_SYNTH_CFG_2 * 4);
+			reg = hantro_hwregs_read(dev,c,HANTRODEC_SYNTH_CFG_2 * 4);
 
 			tmp = (reg >> DWL_HEVC_E) & 0x3U;
 			if (tmp)
@@ -430,7 +496,7 @@ static void ReadCoreConfig(hantrodec_t *dev)
 		}
 
 		/* Post-processor configuration */
-		reg = ioread32(dev->hwregs[c] + HANTRODECPP_SYNTH_CFG * 4);
+		reg = hantro_hwregs_read(dev,c,HANTRODECPP_SYNTH_CFG * 4);
 
 		tmp = (reg >> DWL_PP_E) & 0x01U;
 		if (tmp)
@@ -499,10 +565,29 @@ int GetDecCoreID(hantrodec_t *dev, struct file *filp,
 
 static int hantrodec_choose_core(int is_g1)
 {
+	PDEBUG("hantrodec_choose_core\n");
+
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	struct tee_context *ctx = hantrodec_data.ctx[(is_g1?0:1)];
+	uint32_t session;
+	
+	session = hantro_secure_open(ctx,0xFFFFFFFF);
+	if (session)
+	{
+		if (is_g1)
+		{
+			hantro_secure_regs_write(ctx,session,0x14,0x1); // VPUMIX only use G1
+		} else {
+			hantro_secure_regs_write(ctx,session,0x14,0x0); // VPUMIX only use G2
+		}
+		tee_client_close_session(ctx,session);
+	}
+
+#else
+
 	volatile unsigned char *reg = NULL;
 	unsigned int blk_base = BLK_CTL_BASE;
 
-	PDEBUG("hantrodec_choose_core\n");
 	if (!request_mem_region(blk_base, 0x1000, "blk_ctl"))	{
 		pr_err("blk_ctl: failed to reserve HW regs\n");
 		return -EBUSY;
@@ -525,6 +610,8 @@ static int hantrodec_choose_core(int is_g1)
 	if (reg)
 		iounmap((void *)reg);
 	release_mem_region(blk_base, 0x1000);
+#endif
+
 	PDEBUG("hantrodec_choose_core OK!\n");
 	return 0;
 }
@@ -567,7 +654,7 @@ void ReleaseDecoder(hantrodec_t *dev, long Core)
 	u32 status;
 	unsigned long flags;
 
-	status = ioread32(dev->hwregs[Core] + HANTRODEC_IRQ_STAT_DEC_OFF);
+	status = hantro_hwregs_read(dev,Core,HANTRODEC_IRQ_STAT_DEC_OFF);
 
 	/* make sure HW is disabled */
 	if (status & HANTRODEC_DEC_E) {
@@ -575,7 +662,7 @@ void ReleaseDecoder(hantrodec_t *dev, long Core)
 
 		/* abort decoder */
 		status |= HANTRODEC_DEC_ABORT | HANTRODEC_DEC_IRQ_DISABLE;
-		iowrite32(status, dev->hwregs[Core] + HANTRODEC_IRQ_STAT_DEC_OFF);
+		hantro_hwregs_write(dev,Core,HANTRODEC_IRQ_STAT_DEC_OFF,status);
 	}
 
 	spin_lock_irqsave(&owner_lock, flags);
@@ -612,8 +699,9 @@ long ReservePostProcessor(hantrodec_t *dev, struct file *filp)
 void ReleasePostProcessor(hantrodec_t *dev, long Core)
 {
 	unsigned long flags;
+	u32 status;
 
-	u32 status = ioread32(dev->hwregs[Core] + HANTRO_IRQ_STAT_PP_OFF);
+	status = hantro_hwregs_read(dev,Core,HANTRO_IRQ_STAT_PP_OFF);
 
 	/* make sure HW is disabled */
 	if (status & HANTRO_PP_E) {
@@ -624,7 +712,7 @@ void ReleasePostProcessor(hantrodec_t *dev, long Core)
 
 		/* disable postprocessor */
 		status &= (~HANTRO_PP_E);
-		iowrite32(0x10, dev->hwregs[Core] + HANTRO_IRQ_STAT_PP_OFF);
+		hantro_hwregs_write(dev,Core,HANTRO_IRQ_STAT_PP_OFF,0x10);
 	}
 
 	spin_lock_irqsave(&owner_lock, flags);
@@ -698,11 +786,25 @@ long DecFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 
 		/* write dec regs but the status reg[1] to hardware */
 		/* both original and extended regs need to be written */
-		for (i = 2; i <= HANTRO_DEC_ORG_LAST_REG; i++)
-			iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+#ifdef CONFIG_MXC_HANTRO_SECURE
+		if (dev->shm[id])
+			hantro_hwregs_write_multiple(dev->ctx[id],dev->shm[id],dev->session[id],2*4,dec_regs[id],HANTRO_DEC_ORG_LAST_REG*4);
+		else
+#endif
+		{
+			for (i = 2; i <= HANTRO_DEC_ORG_LAST_REG; i++)
+				iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+		}
 #ifdef USE_64BIT_ENV
-		for (i = HANTRO_DEC_EXT_FIRST_REG; i <= HANTRO_DEC_EXT_LAST_REG; i++)
-			iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+#ifdef CONFIG_MXC_HANTRO_SECURE
+		if (dev->shm[id])
+			hantro_hwregs_write_multiple(dev->ctx[id],dev->shm[id],dev->session[id],HANTRO_DEC_EXT_FIRST_REG*4,dec_regs[id],HANTRO_DEC_ORG_LAST_REG*4);
+		else
+#endif
+		{
+			for (i = HANTRO_DEC_EXT_FIRST_REG; i <= HANTRO_DEC_EXT_LAST_REG; i++)
+				iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+		}
 #endif
 	} else {
 		ret = copy_from_user(dec_regs[id], Core->regs, HANTRO_G2_DEC_REGS*4);
@@ -711,13 +813,20 @@ long DecFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 			return -EFAULT;
 		}
 
-		/* write all regs but the status reg[1] to hardware */
-		for (i = 2; i <= HANTRO_G2_DEC_LAST_REG; i++)
-			iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+#ifdef CONFIG_MXC_HANTRO_SECURE
+		if (dev->shm[id])
+			hantro_hwregs_write_multiple(dev->ctx[id],dev->shm[id],dev->session[id],2*4,dec_regs[id],HANTRO_G2_DEC_LAST_REG*4);
+		else
+#endif
+		{
+			/* write all regs but the status reg[1] to hardware */
+			for (i = 2; i <= HANTRO_G2_DEC_LAST_REG; i++)
+				iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+		}
 	}
 
 	/* write the status register, which may start the decoder */
-	iowrite32(dec_regs[id][1], dev->hwregs[id] + 4);
+	hantro_hwregs_write(dev,id,4,dec_regs[id][1]);
 
 	PDEBUG("flushed registers on Core %d\n", id);
 
@@ -737,10 +846,10 @@ long DecRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 		/* read all registers from hardware */
 		/* both original and extended regs need to be read */
 		for (i = 0; i <= HANTRO_DEC_ORG_LAST_REG; i++)
-			dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
+			dec_regs[id][i] = hantro_hwregs_read(dev,id, i*4);
 #ifdef USE_64BIT_ENV
 		for (i = HANTRO_DEC_EXT_FIRST_REG; i <= HANTRO_DEC_EXT_LAST_REG; i++)
-			dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
+			dec_regs[id][i] = hantro_hwregs_read(dev,id, i*4);
 #endif
 
 		if (timeout) {
@@ -770,7 +879,7 @@ long DecRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 
 		/* read all registers from hardware */
 		for (i = 0; i <= HANTRO_G2_DEC_LAST_REG; i++)
-			dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
+			dec_regs[id][i] = hantro_hwregs_read(dev,id, i*4);
 
 		if (timeout) {
 			/* Enable TIMEOUT bits in Reg[1] */
@@ -817,17 +926,27 @@ long WaitDecReadyAndRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 
 	PDEBUG("wait_event_interruptible DEC[%d]\n", id);
 
-	//ret = wait_event_interruptible_timeout(dec_wait_queue, CheckDecIrq(dev, id), msecs_to_jiffies(200));
-	ret = wait_event_timeout(dec_wait_queue, CheckDecIrq(dev, id), msecs_to_jiffies(200));
-	if (ret == -ERESTARTSYS) {
-		pr_err("DEC[%d]  failed to wait_event interrupted\n", id);
-		return -ERESTARTSYS;
-	} else if (ret == 0) {
-		pr_err("DEC[%d]  wait_event timeout\n", id);
-		timeout = 1;
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	if (dev->session)
+	{
+		if (hantro_secure_wait(dev->ctx[id],dev->session[id]))
+			return -EINVAL;
 	}
+	else
+#endif
+	{
+		//ret = wait_event_interruptible_timeout(dec_wait_queue, CheckDecIrq(dev, id), msecs_to_jiffies(200));
+		ret = wait_event_timeout(dec_wait_queue, CheckDecIrq(dev, id), msecs_to_jiffies(200));
+		if (ret == -ERESTARTSYS) {
+			pr_err("DEC[%d]  failed to wait_event interrupted\n", id);
+			return -ERESTARTSYS;
+		} else if (ret == 0) {
+			pr_err("DEC[%d]  wait_event timeout\n", id);
+			timeout = 1;
+		}
 
-	atomic_inc(&irq_tx);
+		atomic_inc(&irq_tx);
+	}
 
 	/* refresh registers */
 	return DecRefreshRegs(dev, Core);
@@ -854,15 +973,28 @@ long PPFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 
 	/* write all regs but the status reg[1] to hardware */
 	/* both original and extended regs need to be written */
-	for (i = HANTRO_PP_ORG_FIRST_REG + 1; i <= HANTRO_PP_ORG_LAST_REG; i++)
-		iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	if (dev->shm[id])
+		hantro_hwregs_write_multiple(dev->ctx[id],dev->shm[id],dev->session[id],(HANTRO_PP_ORG_FIRST_REG+1)*4,dec_regs[id],HANTRO_PP_ORG_LAST_REG*4);
+	else
+#endif
+	{
+		for (i = HANTRO_PP_ORG_FIRST_REG + 1; i <= HANTRO_PP_ORG_LAST_REG; i++)
+			iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+	}
 #ifdef USE_64BIT_ENV
-	for (i = HANTRO_PP_EXT_FIRST_REG; i <= HANTRO_PP_EXT_LAST_REG; i++)
-		iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	if (dev->shm[id])
+		hantro_hwregs_write_multiple(dev->ctx[id],dev->shm[id],dev->session[id],HANTRO_PP_EXT_FIRST_REG*4,dec_regs[id],HANTRO_PP_EXT_LAST_REG*4);
+	else
+#endif
+	{
+		for (i = HANTRO_PP_EXT_FIRST_REG; i <= HANTRO_PP_EXT_LAST_REG; i++)
+			iowrite32(dec_regs[id][i], dev->hwregs[id] + i*4);
+	}
 #endif
 	/* write the stat reg, which may start the PP */
-	iowrite32(dec_regs[id][HANTRO_PP_ORG_FIRST_REG],
-	dev->hwregs[id] + HANTRO_PP_ORG_FIRST_REG * 4);
+	hantro_hwregs_write(dev,id,HANTRO_PP_ORG_FIRST_REG * 4,dec_regs[id][HANTRO_PP_ORG_FIRST_REG]);
 
 	return 0;
 }
@@ -884,10 +1016,10 @@ long PPRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 	/* read all registers from hardware */
 	/* both original and extended regs need to be read */
 	for (i = HANTRO_PP_ORG_FIRST_REG; i <= HANTRO_PP_ORG_LAST_REG; i++)
-		dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
+		dec_regs[id][i] = hantro_hwregs_read(dev,id, i*4);
 #ifdef USE_64BIT_ENV
 	for (i = HANTRO_PP_EXT_FIRST_REG; i <= HANTRO_PP_EXT_LAST_REG; i++)
-		dec_regs[id][i] = ioread32(dev->hwregs[id] + i*4);
+		dec_regs[id][i] = hantro_hwregs_read(dev,id, i*4);
 #endif
 	/* put registers to user space*/
 	/* put original registers to user space*/
@@ -988,12 +1120,22 @@ long WaitCoreReady(hantrodec_t *dev, const struct file *filp, int *id)
 {
 	PDEBUG("wait_event_interruptible CORE\n");
 
-	if (wait_event_interruptible(dec_wait_queue, CheckCoreIrq(dev, filp, id))) {
-		pr_err("CORE  failed to wait_event_interruptible interrupted\n");
-		return -ERESTARTSYS;
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	if (dev->session)
+	{
+		if (hantro_secure_wait(dev->ctx[*id],dev->session[*id]))
+			return -EINVAL;
 	}
+	else
+#endif
+	{
+		if (wait_event_interruptible(dec_wait_queue, CheckCoreIrq(dev, filp, id))) {
+			pr_err("CORE  failed to wait_event_interruptible interrupted\n");
+			return -ERESTARTSYS;
+		}
 
-	atomic_inc(&irq_tx);
+		atomic_inc(&irq_tx);
+	}
 
 	return 0;
 }
@@ -1221,7 +1363,7 @@ static long hantrodec_ioctl(struct file *filp, unsigned int cmd, unsigned long a
 		__get_user(id, (u32 *)arg);
 		if (id >= hantrodec_data.cores)
 			return -EFAULT;
-		id = ioread32(hantrodec_data.hwregs[id]);
+		id = hantro_hwregs_read(&hantrodec_data,id, 0);
 		__put_user(id, (u32 *) arg);
 		return 0;
 	}
@@ -1436,10 +1578,7 @@ static const struct file_operations hantrodec_fops = {
 int hantrodec_init(struct platform_device *pdev)
 {
 	int result;
-	int irq_0, irq_1;
 
-	dec_irq = 0;
-	pp_irq = 0;
 	pr_debug("hantrodec: Init multi Core[0] at 0x%16lx\n"
 			"                     Core[1] at 0x%16lx\n", multicorebase[0], multicorebase[1]);
 
@@ -1468,12 +1607,33 @@ int hantrodec_init(struct platform_device *pdev)
 	sema_init(&dec_core_sem, hantrodec_data.cores-1);
 	sema_init(&pp_core_sem, 1);
 
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	int n;
+
+	for (n=0; n<hantrodec_data.cores; n++)
+	{
+		hantrodec_data.ctx[n] = hantro_secure_open_context();
+
+		if (hantrodec_data.ctx[n])
+		{
+			hantrodec_data.shm[n] = alloc_shm(hantrodec_data.ctx[n],DEC_IO_SIZE_MAX/4);
+			hantrodec_data.session[n] = hantro_secure_open(hantrodec_data.ctx[n],n);
+		}
+	}
+#endif
+
 	/* read configuration fo all cores */
 	ReadCoreConfig(&hantrodec_data);
 
 	/* reset hardware */
 	ResetAsic(&hantrodec_data);
 
+#ifndef CONFIG_MXC_HANTRO_SECURE
+	int irq_0, irq_1;
+
+	dec_irq = 0;
+	pp_irq = 0;
+
 	/* register irq for each core*/
 	irq_0 = platform_get_irq_byname(pdev, "irq_hantro_g1");
 	if (irq_0 > 0) {
@@ -1517,6 +1677,8 @@ int hantrodec_init(struct platform_device *pdev)
 		pr_err("hantrodec: IRQ1 not in use!\n");
 		goto err;
 	}
+#endif
+
 	pr_info("hantrodec: module inserted. Major = %d\n", hantrodec_major);
 
 	return 0;
@@ -1549,6 +1711,19 @@ void hantrodec_cleanup(void)
 
 	ReleaseIO();
 
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	for (n = 0; n < dev->cores; n++) {
+		if (dev->session[n])
+		{
+			tee_client_close_session(dev->ctx[n], dev->session[n]);
+		}
+		if (dev->shm[n])
+		{
+			release_shm(dev->shm[n]);
+		}
+	}
+#endif
+
 	unregister_chrdev(hantrodec_major, "hantrodec");
 
 	PDEBUG("hantrodec: module removed\n");
@@ -1652,6 +1827,7 @@ static void ReleaseIO(void)
 	}
 }
 
+#ifndef CONFIG_MXC_HANTRO_SECURE
 /*---------------------------------------------------------------------------
  *Function name   : hantrodec_isr
  *Description     : interrupt handler
@@ -1702,6 +1878,7 @@ irqreturn_t hantrodec_isr(int irq, void *dev_id)
 	(void)hwregs;
 	return IRQ_RETVAL(handled);
 }
+#endif
 
 /*---------------------------------------------------------------------------
  *Function name   : ResetAsic
@@ -1716,20 +1893,20 @@ void ResetAsic(hantrodec_t *dev)
 	u32 status;
 
 	for (j = 0; j < dev->cores; j++) {
-		status = ioread32(dev->hwregs[j] + HANTRODEC_IRQ_STAT_DEC_OFF);
+		status = hantro_hwregs_read(dev,j, HANTRODEC_IRQ_STAT_DEC_OFF);
 
 		if (status & HANTRODEC_DEC_E) {
 			/* abort with IRQ disabled */
 			status = HANTRODEC_DEC_ABORT | HANTRODEC_DEC_IRQ_DISABLE;
-			iowrite32(status, dev->hwregs[j] + HANTRODEC_IRQ_STAT_DEC_OFF);
+			hantro_hwregs_write(dev,j,HANTRODEC_IRQ_STAT_DEC_OFF,status);
 		}
 
 		if (IS_G1(dev->hw_id[j]))
 			/* reset PP */
-			iowrite32(0, dev->hwregs[j] + HANTRO_IRQ_STAT_PP_OFF);
+			hantro_hwregs_write(dev,j,HANTRO_IRQ_STAT_PP_OFF,0);
 
 		for (i = 4; i < dev->iosize[j]; i += 4)
-			iowrite32(0, dev->hwregs[j] + i);
+			hantro_hwregs_write(dev,j,i,0);
 	}
 }
 
@@ -1749,10 +1926,10 @@ void dump_regs(hantrodec_t *dev)
 	for (c = 0; c < dev->cores; c++) {
 		for (i = 0; i < dev->iosize[c]; i += 4*4) {
 			PDEBUG("\toffset %04X: %08X  %08X  %08X  %08X\n", i,
-			ioread32(dev->hwregs[c] + i),
-			ioread32(dev->hwregs[c] + i + 4),
-			ioread32(dev->hwregs[c] + i + 8),
-			ioread32(dev->hwregs[c] + i + 12));
+			hantro_hwregs_read(dev,c, i),
+			hantro_hwregs_read(dev,c, i + 4),
+			hantro_hwregs_read(dev,c, i + 8),
+			hantro_hwregs_read(dev,c, i + 12));
 		}
 	}
 	PDEBUG("Reg Dump End\n");
@@ -1855,6 +2032,19 @@ static int hantro_dev_remove(struct platform_device *pdev)
 	HANTRO_UNREG_THERMAL_NOTIFIER(&hantro_thermal_hot_notifier);
 #endif
 
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	int n;
+
+	for (n=0;n<hantrodec_data.cores;n++)
+	{
+		if (hantrodec_data.ctx[n])
+		{
+			tee_client_close_context(hantrodec_data.ctx[n]);
+			hantrodec_data.ctx[n] = NULL;
+		}
+	}
+#endif
+
 	return 0;
 }
 
diff --git a/drivers/mxc/hantro_845/Kconfig b/drivers/mxc/hantro_845/Kconfig
index b14e35f..6b59c33 100755
--- a/drivers/mxc/hantro_845/Kconfig
+++ b/drivers/mxc/hantro_845/Kconfig
@@ -11,11 +11,4 @@ config MXC_HANTRO_845
 	---help---
 	  VPU codec device.
 
-config MXC_HANTRO_SECURE
-	tristate "Support for Secure VPU driver with OPTEE"
-	depends on TEE && OPTEE
-	default y
-	---help---
-	  VPU secure driver.
-
 endmenu
diff --git a/drivers/mxc/hantro_845/Makefile b/drivers/mxc/hantro_845/Makefile
index 98585be..454d903 100755
--- a/drivers/mxc/hantro_845/Makefile
+++ b/drivers/mxc/hantro_845/Makefile
@@ -3,7 +3,7 @@
 #
 
 #ccflags-y += -I$(PWD)
+ccflags-$(CONFIG_MXC_HANTRO_SECURE) += -Idrivers/mxc/hantro_secure
 
 obj-$(CONFIG_MXC_HANTRO_845) += hantrodec_845s.o
-obj-$(CONFIG_MXC_HANTRO_SECURE) += hantrodec_secure.o
 
diff --git a/drivers/mxc/hantro_845/hantrodec_845s.c b/drivers/mxc/hantro_845/hantrodec_845s.c
index 78a8fa0..0ba5124 100755
--- a/drivers/mxc/hantro_845/hantrodec_845s.c
+++ b/drivers/mxc/hantro_845/hantrodec_845s.c
@@ -51,9 +51,10 @@
 
 #include <linux/delay.h>
 
-#include "hantrodec_secure.h"
+#ifdef CONFIG_MXC_HANTRO_SECURE
+#include <hantrodec_secure.h>
+#endif
 
-#define CONFIG_HANTRO_SECURE
 //#define CONFIG_DEVICE_THERMAL_HANTRO
 #ifdef CONFIG_DEVICE_THERMAL_HANTRO
 #include <linux/device_cooling.h>
@@ -167,7 +168,7 @@ static int cores = 2;
 
 /* here's all the must remember stuff */
 typedef struct {
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	struct tee_context *ctx;
  	uint32_t session;
 	struct tee_shm* shm;
@@ -215,7 +216,7 @@ static void ResetAsic(hantrodec_t *dev);
 static void dump_regs(hantrodec_t *dev);
 #endif
 
-#ifndef CONFIG_HANTRO_SECURE
+#ifndef CONFIG_MXC_HANTRO_SECURE
 /* IRQ handler */
 static irqreturn_t hantrodec_isr(int irq, void *dev_id);
 #endif
@@ -282,7 +283,7 @@ static int hantro_ctrlblk_reset(hantrodec_t *dev)
 	//config G1/G2
 	hantro_clk_enable(&dev->clk);
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	uint32_t session;
 	
 	session = hantro_secure_open(dev->ctx,0xFFFFFFFF);
@@ -446,7 +447,7 @@ static struct notifier_block hantro_thermal_hot_notifier = {
 static void hantro_hwregs_write(hantrodec_t *dev,
 		       uint32_t offset, uint32_t value)
 {
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->session)
 	{
 		hantro_secure_regs_write(dev->ctx,dev->session,offset,value);
@@ -461,7 +462,7 @@ static void hantro_hwregs_write(hantrodec_t *dev,
 static uint32_t hantro_hwregs_read(hantrodec_t *dev,
 		       uint32_t offset)
 {
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->session)
 	{
 		return hantro_secure_regs_read(dev->ctx,dev->session,offset);
@@ -835,7 +836,7 @@ static long DecFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 		/* write dec regs but the status reg[1] to hardware */
 		/* both original and extended regs need to be written */
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 		if (dev->shm)
 			hantro_hwregs_write_multiple(dev->ctx,dev->shm,dev->session,2*4,dev->dec_regs,HANTRO_DEC_ORG_LAST_REG*4);
 		else
@@ -845,7 +846,7 @@ static long DecFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 				hantro_hwregs_write(dev,i*4,dev->dec_regs[i]);
 		}
 #ifdef USE_64BIT_ENV
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 		if (dev->shm)
 			hantro_hwregs_write_multiple(dev->ctx,dev->shm,dev->session,HANTRO_DEC_EXT_FIRST_REG*4,dev->dec_regs,HANTRO_DEC_ORG_LAST_REG*4);
 		else
@@ -863,7 +864,7 @@ static long DecFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 		}
 
 		/* write all regs but the status reg[1] to hardware */
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 		if (dev->shm)
 			hantro_hwregs_write_multiple(dev->ctx,dev->shm,dev->session,2*4,dev->dec_regs,HANTRO_G2_DEC_LAST_REG*4);
 		else
@@ -895,7 +896,7 @@ static long DecRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 		/* read all registers from hardware */
 		/* both original and extended regs need to be read */
 		for (i = 0; i <= HANTRO_DEC_ORG_LAST_REG; i++)
-			dev->dec_regs[i] = hantro_hwregs_read(dev, + i*4);
+			dev->dec_regs[i] = hantro_hwregs_read(dev, i*4);
 #ifdef USE_64BIT_ENV
 		for (i = HANTRO_DEC_EXT_FIRST_REG; i <= HANTRO_DEC_EXT_LAST_REG; i++)
 			dev->dec_regs[i] = hantro_hwregs_read(dev, i*4);
@@ -975,7 +976,7 @@ static long WaitDecReadyAndRefreshRegs(hantrodec_t *dev, struct core_desc *Core)
 
 	PDEBUG("wait_event_interruptible DEC[%d]\n", dev->core_id);
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->session)
 	{
 		if (hantro_secure_wait(dev->ctx,dev->session))
@@ -1022,7 +1023,7 @@ static long PPFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 
 	/* write all regs but the status reg[1] to hardware */
 	/* both original and extended regs need to be written */
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->shm)
 		hantro_hwregs_write_multiple(dev->ctx,dev->shm,dev->session,(HANTRO_PP_ORG_FIRST_REG+1)*4,dev->dec_regs,HANTRO_PP_ORG_LAST_REG*4);
 	else
@@ -1032,7 +1033,7 @@ static long PPFlushRegs(hantrodec_t *dev, struct core_desc *Core)
 			hantro_hwregs_write(dev,i*4,dev->dec_regs[i]);
 	}
 #ifdef USE_64BIT_ENV
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->shm)
 		hantro_hwregs_write_multiple(dev->ctx,dev->shm,dev->session,HANTRO_PP_EXT_FIRST_REG*4,dev->dec_regs,HANTRO_PP_EXT_LAST_REG*4);
 	else
@@ -1175,7 +1176,7 @@ static long WaitCoreReady(const struct file *filp, int *id)
 
 	PDEBUG("wait_event_interruptible CORE\n");
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->session)
 	{
 		if (hantro_secure_wait(dev->ctx,dev->session))
@@ -1733,13 +1734,18 @@ static int hantrodec_init(struct platform_device *pdev, int id)
 	sema_init(&dev->dec_core_sem, 1);
 	sema_init(&dev->pp_core_sem, 1);
 
+#ifdef CONFIG_MXC_HANTRO_SECURE
+	dev->shm = alloc_shm(dev->ctx,DEC_IO_SIZE_MAX/4);
+	dev->session = hantro_secure_open(dev->ctx,id);
+#endif
+
 	/* read configuration fo all cores */
 	ReadCoreConfig(dev);
 
 	/* reset hardware */
 	ResetAsic(dev);
 
-#ifndef CONFIG_HANTRO_SECURE
+#ifndef CONFIG_MXC_HANTRO_SECURE
 	int irq;
 	/* register irq for each core*/
 	irq = platform_get_irq_byname(pdev, "irq_hantro");
@@ -1767,11 +1773,6 @@ static int hantrodec_init(struct platform_device *pdev, int id)
 	irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
 #endif
 
-#ifdef CONFIG_HANTRO_SECURE
-	dev->shm = alloc_shm(dev->ctx,DEC_IO_SIZE_MAX/4);
-	dev->session = hantro_secure_open(dev->ctx,id);
-#endif
-
 	pr_info("hantrodec %d : module inserted. Major = %d\n", id, hantrodec_major);
 
 	return 0;
@@ -1809,7 +1810,7 @@ static void hantrodec_cleanup(int id)
 
 	//unregister_chrdev(hantrodec_major, "hantrodec");
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->session)
 	{
 		tee_client_close_session(dev->ctx, dev->session);
@@ -1921,7 +1922,7 @@ static void ReleaseIO(int i)
 	//}
 }
 
-#ifndef CONFIG_HANTRO_SECURE
+#ifndef CONFIG_MXC_HANTRO_SECURE
 /*---------------------------------------------------------------------------
  *Function name   : hantrodec_isr
  *Description     : interrupt handler
@@ -2064,7 +2065,7 @@ static int hantro_dev_probe(struct platform_device *pdev)
 	pr_debug("hantro: dec, bus clock: 0x%lX, 0x%lX\n", clk_get_rate(hantrodec_data[id].clk.dec),
 				clk_get_rate(hantrodec_data[id].clk.bus));
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	hantrodec_data[id].ctx = hantro_secure_open_context();
 #endif
 
@@ -2123,7 +2124,7 @@ static int hantro_dev_remove(struct platform_device *pdev)
 	HANTRO_UNREG_THERMAL_NOTIFIER(&hantro_thermal_hot_notifier);
 #endif
 
-#ifdef CONFIG_HANTRO_SECURE
+#ifdef CONFIG_MXC_HANTRO_SECURE
 	if (dev->ctx)
 	{
 		tee_client_close_context(dev->ctx);
diff --git a/drivers/mxc/hantro_845/hantrodec_secure.c b/drivers/mxc/hantro_845/hantrodec_secure.c
deleted file mode 100644
index 462f990..00000000
--- a/drivers/mxc/hantro_845/hantrodec_secure.c
+++ /dev/null
@@ -1,262 +0,0 @@
-/*****************************************************************************
- *    The GPL License (GPL)
- *
- *    Copyright (c) 2019 NXP
- *
- *    This program is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU General Public License
- *    as published by the Free Software Foundation; either version 2
- *    of the License, or (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
- *    You may obtain a copy of the GNU General Public License
- *    Version 2 or later at the following locations:
- *    http://www.opensource.org/licenses/gpl-license.html
- *    http://www.gnu.org/copyleft/gpl.html
- *****************************************************************************/
-#include <linux/tee_drv.h>
-
-/** @brief  PTA UUID generated at https://www.gguid.com/ */
-#define PTA_HANTRO_VPU_PTA_UUID {0xf45a8128,0x23ff,0x4949,{0x98,0xa4,0x58,0xcb,0x8a,0xef,0x5a,0x75}}
-
-#define PTA_HANTRO_VPU_CMD_WAIT				0
-#define PTA_HANTRO_VPU_CMD_READ				1
-#define PTA_HANTRO_VPU_CMD_WRITE			2
-#define PTA_HANTRO_VPU_CMD_WRITE_MULTIPLE	3
-
-typedef struct {
-       uint32_t timeLow;
-       uint16_t timeMid;
-       uint16_t timeHiAndVersion;
-       uint8_t clockSeqAndNode[8];
-} RTC_UUID;
-
-struct tee_shm *alloc_shm(struct tee_context *ctx, size_t size)
-{
-	if (ctx == NULL)
-		return NULL;
-
-	return tee_shm_alloc(ctx,size,TEE_SHM_MAPPED);
-}
-
-void release_shm(struct tee_shm *shm)
-{
-	if (shm)
-		tee_shm_free(shm);
-}
-
-void hantro_secure_regs_write(struct tee_context *ctx, uint32_t session,
-		       uint32_t offset, uint32_t value)
-{
-	int ret = 0;
-	struct tee_ioctl_invoke_arg inv_arg;
-	struct tee_param param[4];
-
-	if (ctx == NULL)
-		return;
-
-	memset(&inv_arg, 0, sizeof(inv_arg));
-	memset(&param, 0, sizeof(param));
-
-	/* Invoke PTA_HANTRO_VPU_CMD_WRITE function */
-	inv_arg.func = PTA_HANTRO_VPU_CMD_WRITE;
-	inv_arg.session = session;
-	inv_arg.num_params = 4;
-
-	/* Fill invoke cmd params */
-	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
-	param[0].u.value.a = offset;
-	param[0].u.value.b = value;
-
-	ret = tee_client_invoke_func(ctx, &inv_arg, param);
-	if ((ret < 0) || inv_arg.ret) {
-		pr_err("PTA_HANTRO_VPU_CMD_WRITE invoke function err: 0x%08X 0x%08X\n",
-		       ret,inv_arg.ret);
-	}
-}
-
-void hantro_hwregs_write_multiple(struct tee_context *ctx, struct tee_shm* shm, uint32_t session,
-		       uint32_t offset, void *regs, uint32_t size)
-{
-	int ret = 0;
-	struct tee_ioctl_invoke_arg inv_arg;
-	struct tee_param param[4];
-
-	if (ctx == NULL)
-		return;
-	// check buffer overflow
-	if (offset + size < offset)
-		return;
-
-	memcpy(tee_shm_get_va(shm,offset),regs + offset,size);
-	memset(&inv_arg, 0, sizeof(inv_arg));
-	memset(&param, 0, sizeof(param));
-
-	/* Invoke PTA_HANTRO_VPU_CMD_WRITE function */
-	inv_arg.func = PTA_HANTRO_VPU_CMD_WRITE_MULTIPLE;
-	inv_arg.session = session;
-	inv_arg.num_params = 4;
-
-	/* Fill invoke cmd params */
-	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
-	param[0].u.value.a = offset;
-	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
-	param[1].u.memref.shm_offs = offset;
-	param[1].u.memref.size = size;
-	param[1].u.memref.shm = shm;
-
-	ret = tee_client_invoke_func(ctx, &inv_arg, param);
-	if ((ret < 0) || inv_arg.ret) {
-		pr_err("PTA_HANTRO_VPU_CMD_WRITE_MULTIPLE invoke function err: 0x%08X 0x%08X\n",
-		       ret,inv_arg.ret);
-	}
-}
-
-uint32_t hantro_secure_regs_read(struct tee_context *ctx, uint32_t session,
-		       uint32_t offset)
-{
-	int ret = 0;
-	struct tee_ioctl_invoke_arg inv_arg;
-	struct tee_param param[4];
-
-	if (ctx == NULL)
-		return 0;
-
-	memset(&inv_arg, 0, sizeof(inv_arg));
-	memset(&param, 0, sizeof(param));
-
-	/* Invoke PTA_HANTRO_VPU_CMD_READ function */
-	inv_arg.func = PTA_HANTRO_VPU_CMD_READ;
-	inv_arg.session = session;
-	inv_arg.num_params = 4;
-
-	/* Fill invoke cmd params */
-	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
-	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
-	param[0].u.value.a = offset;
-
-	ret = tee_client_invoke_func(ctx, &inv_arg, param);
-	if ((ret < 0) || inv_arg.ret) {
-		pr_err("PTA_HANTRO_VPU_CMD_READ invoke function err: 0x%08X 0x%08X\n",
-		       ret,inv_arg.ret);
-		return 0;
-	}
-	return param[1].u.value.a;
-}
-
-uint32_t hantro_secure_wait(struct tee_context *ctx, uint32_t session)
-{
-	int ret = 0;
-	struct tee_ioctl_invoke_arg inv_arg;
-	struct tee_param param[4];
-
-	if (ctx == NULL)
-		return -1;
-
-	memset(&inv_arg, 0, sizeof(inv_arg));
-	memset(&param, 0, sizeof(param));
-
-	/* Invoke PTA_HANTRO_VPU_CMD_WRITE function */
-	inv_arg.func = PTA_HANTRO_VPU_CMD_WAIT;
-	inv_arg.session = session;
-	inv_arg.num_params = 4;
-
-	/* Fill invoke cmd params */
-	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
-	param[0].u.value.a = 200; // 200ms timeout
-
-	ret = tee_client_invoke_func(ctx, &inv_arg, param);
-	if ((ret < 0) || inv_arg.ret) {
-		pr_err("PTA_HANTRO_VPU_CMD_WAIT invoke function err: 0x%08X 0x%08X\n",
-		       ret,inv_arg.ret);
-		return -1;
-	}
-	return 0;
-}
-
-static int hantrodec_optee_match(struct tee_ioctl_version_data *ver,
-				const void *data)
-{
-	if (ver->impl_id == TEE_IMPL_ID_OPTEE)
-		return 1;
-	else
-		return 0;
-}
-
-struct tee_context* hantro_secure_open_context(void)
-{
-	struct tee_context *ctx;
-	struct tee_ioctl_version_data vers = {
-		.impl_id = TEE_OPTEE_CAP_TZ,
-		.impl_caps = TEE_IMPL_ID_OPTEE,
-		.gen_caps = TEE_GEN_CAP_GP,
-	};
-
-	ctx = tee_client_open_context(NULL, hantrodec_optee_match,
-					     NULL, &vers);
-
-	if (IS_ERR(ctx))
-	{
-		pr_err("unable to open tee ctx %p\n",(void*)ctx);
-		ctx = NULL;
-	}
-
-	return ctx;
-}
-
-static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const RTC_UUID *s)
-{
-       d[0] = s->timeLow >> 24;
-       d[1] = s->timeLow >> 16;
-       d[2] = s->timeLow >> 8;
-       d[3] = s->timeLow;
-       d[4] = s->timeMid >> 8;
-       d[5] = s->timeMid;
-       d[6] = s->timeHiAndVersion >> 8;
-       d[7] = s->timeHiAndVersion;
-       memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
-}
-
-uint32_t hantro_secure_open(struct tee_context* ctx, uint32_t id)
-{
-	const RTC_UUID pta_uuid = PTA_HANTRO_VPU_PTA_UUID;
-	struct tee_ioctl_open_session_arg sess_arg;
-	struct tee_param param[4];
-	struct tee_param *params = NULL;
-	int result;
-
-	if (ctx == NULL)
-		return 0;
-
-	memset(&sess_arg, 0, sizeof(sess_arg));
-	memset(&param, 0, sizeof(param));
-
-	/* Open session with pseudo TA */
-	uuid_to_octets(sess_arg.uuid, &pta_uuid);
-	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
-
-	if (id != 0xFFFFFFFF)
-	{
-		sess_arg.num_params = 4;
-
-		/* Fill invoke cmd params */
-		param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
-		param[0].u.value.a = id;
-
-		params = param;
-	} else {
-		sess_arg.num_params = 0;
-	}
-
-	result = tee_client_open_session(ctx, &sess_arg, params);
-	if ((result < 0) || sess_arg.ret) {
-		pr_err("unable to open pta session 0x%08X\n",sess_arg.ret);
-		return 0;
-	}
-
-	return sess_arg.session;
-}
diff --git a/drivers/mxc/hantro_845/hantrodec_secure.h b/drivers/mxc/hantro_845/hantrodec_secure.h
deleted file mode 100644
index 983d937..00000000
--- a/drivers/mxc/hantro_845/hantrodec_secure.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*****************************************************************************
- *    The GPL License (GPL)
- *
- *    Copyright (c) 2019 NXP
- *
- *    This program is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU General Public License
- *    as published by the Free Software Foundation; either version 2
- *    of the License, or (at your option) any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
- *    You may obtain a copy of the GNU General Public License
- *    Version 2 or later at the following locations:
- *    http://www.opensource.org/licenses/gpl-license.html
- *    http://www.gnu.org/copyleft/gpl.html
- *****************************************************************************/
-#include <linux/tee_drv.h>
-
-struct tee_shm *alloc_shm(struct tee_context *ctx, size_t size);
-
-void release_shm(struct tee_shm *shm);
-
-void hantro_secure_regs_write(struct tee_context *ctx, uint32_t session,
-		       uint32_t offset, uint32_t value);
-
-void hantro_hwregs_write_multiple(struct tee_context *ctx, struct tee_shm* shm, uint32_t session,
-		       uint32_t offset, void *regs, uint32_t size);
-
-uint32_t hantro_secure_regs_read(struct tee_context *ctx, uint32_t session,
-		       uint32_t offset);
-
-uint32_t hantro_secure_wait(struct tee_context *ctx, uint32_t session);
-
-struct tee_context* hantro_secure_open_context(void);
-
-uint32_t hantro_secure_open(struct tee_context *ctx, uint32_t id);
-
-int hantrodec_optee_match(struct tee_ioctl_version_data *ver,
-				const void *data);
-
diff --git a/drivers/mxc/hantro_secure/Kconfig b/drivers/mxc/hantro_secure/Kconfig
new file mode 100644
index 00000000..0720fb1
--- /dev/null
+++ b/drivers/mxc/hantro_secure/Kconfig
@@ -0,0 +1,15 @@
+#
+# Codec configuration
+#
+
+menu "MXC HANTRO(Video Processing Unit) 845 support"
+	depends on ARCH_FSL_IMX8MQ
+
+config MXC_HANTRO_SECURE
+	tristate "Support for Secure VPU driver with OPTEE"
+	depends on TEE && OPTEE
+	default n
+	---help---
+	  VPU secure driver.
+
+endmenu
diff --git a/drivers/mxc/hantro_secure/Makefile b/drivers/mxc/hantro_secure/Makefile
new file mode 100644
index 00000000..ddebd7c
--- /dev/null
+++ b/drivers/mxc/hantro_secure/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the Secure VPU drivers.
+#
+
+obj-$(CONFIG_MXC_HANTRO_SECURE) += hantrodec_secure.o
+
diff --git a/drivers/mxc/hantro_secure/hantrodec_secure.c b/drivers/mxc/hantro_secure/hantrodec_secure.c
new file mode 100644
index 00000000..462f990
--- /dev/null
+++ b/drivers/mxc/hantro_secure/hantrodec_secure.c
@@ -0,0 +1,262 @@
+/*****************************************************************************
+ *    The GPL License (GPL)
+ *
+ *    Copyright (c) 2019 NXP
+ *
+ *    This program is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU General Public License
+ *    as published by the Free Software Foundation; either version 2
+ *    of the License, or (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You may obtain a copy of the GNU General Public License
+ *    Version 2 or later at the following locations:
+ *    http://www.opensource.org/licenses/gpl-license.html
+ *    http://www.gnu.org/copyleft/gpl.html
+ *****************************************************************************/
+#include <linux/tee_drv.h>
+
+/** @brief  PTA UUID generated at https://www.gguid.com/ */
+#define PTA_HANTRO_VPU_PTA_UUID {0xf45a8128,0x23ff,0x4949,{0x98,0xa4,0x58,0xcb,0x8a,0xef,0x5a,0x75}}
+
+#define PTA_HANTRO_VPU_CMD_WAIT				0
+#define PTA_HANTRO_VPU_CMD_READ				1
+#define PTA_HANTRO_VPU_CMD_WRITE			2
+#define PTA_HANTRO_VPU_CMD_WRITE_MULTIPLE	3
+
+typedef struct {
+       uint32_t timeLow;
+       uint16_t timeMid;
+       uint16_t timeHiAndVersion;
+       uint8_t clockSeqAndNode[8];
+} RTC_UUID;
+
+struct tee_shm *alloc_shm(struct tee_context *ctx, size_t size)
+{
+	if (ctx == NULL)
+		return NULL;
+
+	return tee_shm_alloc(ctx,size,TEE_SHM_MAPPED);
+}
+
+void release_shm(struct tee_shm *shm)
+{
+	if (shm)
+		tee_shm_free(shm);
+}
+
+void hantro_secure_regs_write(struct tee_context *ctx, uint32_t session,
+		       uint32_t offset, uint32_t value)
+{
+	int ret = 0;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[4];
+
+	if (ctx == NULL)
+		return;
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	/* Invoke PTA_HANTRO_VPU_CMD_WRITE function */
+	inv_arg.func = PTA_HANTRO_VPU_CMD_WRITE;
+	inv_arg.session = session;
+	inv_arg.num_params = 4;
+
+	/* Fill invoke cmd params */
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = offset;
+	param[0].u.value.b = value;
+
+	ret = tee_client_invoke_func(ctx, &inv_arg, param);
+	if ((ret < 0) || inv_arg.ret) {
+		pr_err("PTA_HANTRO_VPU_CMD_WRITE invoke function err: 0x%08X 0x%08X\n",
+		       ret,inv_arg.ret);
+	}
+}
+
+void hantro_hwregs_write_multiple(struct tee_context *ctx, struct tee_shm* shm, uint32_t session,
+		       uint32_t offset, void *regs, uint32_t size)
+{
+	int ret = 0;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[4];
+
+	if (ctx == NULL)
+		return;
+	// check buffer overflow
+	if (offset + size < offset)
+		return;
+
+	memcpy(tee_shm_get_va(shm,offset),regs + offset,size);
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	/* Invoke PTA_HANTRO_VPU_CMD_WRITE function */
+	inv_arg.func = PTA_HANTRO_VPU_CMD_WRITE_MULTIPLE;
+	inv_arg.session = session;
+	inv_arg.num_params = 4;
+
+	/* Fill invoke cmd params */
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = offset;
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	param[1].u.memref.shm_offs = offset;
+	param[1].u.memref.size = size;
+	param[1].u.memref.shm = shm;
+
+	ret = tee_client_invoke_func(ctx, &inv_arg, param);
+	if ((ret < 0) || inv_arg.ret) {
+		pr_err("PTA_HANTRO_VPU_CMD_WRITE_MULTIPLE invoke function err: 0x%08X 0x%08X\n",
+		       ret,inv_arg.ret);
+	}
+}
+
+uint32_t hantro_secure_regs_read(struct tee_context *ctx, uint32_t session,
+		       uint32_t offset)
+{
+	int ret = 0;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[4];
+
+	if (ctx == NULL)
+		return 0;
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	/* Invoke PTA_HANTRO_VPU_CMD_READ function */
+	inv_arg.func = PTA_HANTRO_VPU_CMD_READ;
+	inv_arg.session = session;
+	inv_arg.num_params = 4;
+
+	/* Fill invoke cmd params */
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+	param[0].u.value.a = offset;
+
+	ret = tee_client_invoke_func(ctx, &inv_arg, param);
+	if ((ret < 0) || inv_arg.ret) {
+		pr_err("PTA_HANTRO_VPU_CMD_READ invoke function err: 0x%08X 0x%08X\n",
+		       ret,inv_arg.ret);
+		return 0;
+	}
+	return param[1].u.value.a;
+}
+
+uint32_t hantro_secure_wait(struct tee_context *ctx, uint32_t session)
+{
+	int ret = 0;
+	struct tee_ioctl_invoke_arg inv_arg;
+	struct tee_param param[4];
+
+	if (ctx == NULL)
+		return -1;
+
+	memset(&inv_arg, 0, sizeof(inv_arg));
+	memset(&param, 0, sizeof(param));
+
+	/* Invoke PTA_HANTRO_VPU_CMD_WRITE function */
+	inv_arg.func = PTA_HANTRO_VPU_CMD_WAIT;
+	inv_arg.session = session;
+	inv_arg.num_params = 4;
+
+	/* Fill invoke cmd params */
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = 200; // 200ms timeout
+
+	ret = tee_client_invoke_func(ctx, &inv_arg, param);
+	if ((ret < 0) || inv_arg.ret) {
+		pr_err("PTA_HANTRO_VPU_CMD_WAIT invoke function err: 0x%08X 0x%08X\n",
+		       ret,inv_arg.ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int hantrodec_optee_match(struct tee_ioctl_version_data *ver,
+				const void *data)
+{
+	if (ver->impl_id == TEE_IMPL_ID_OPTEE)
+		return 1;
+	else
+		return 0;
+}
+
+struct tee_context* hantro_secure_open_context(void)
+{
+	struct tee_context *ctx;
+	struct tee_ioctl_version_data vers = {
+		.impl_id = TEE_OPTEE_CAP_TZ,
+		.impl_caps = TEE_IMPL_ID_OPTEE,
+		.gen_caps = TEE_GEN_CAP_GP,
+	};
+
+	ctx = tee_client_open_context(NULL, hantrodec_optee_match,
+					     NULL, &vers);
+
+	if (IS_ERR(ctx))
+	{
+		pr_err("unable to open tee ctx %p\n",(void*)ctx);
+		ctx = NULL;
+	}
+
+	return ctx;
+}
+
+static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const RTC_UUID *s)
+{
+       d[0] = s->timeLow >> 24;
+       d[1] = s->timeLow >> 16;
+       d[2] = s->timeLow >> 8;
+       d[3] = s->timeLow;
+       d[4] = s->timeMid >> 8;
+       d[5] = s->timeMid;
+       d[6] = s->timeHiAndVersion >> 8;
+       d[7] = s->timeHiAndVersion;
+       memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
+}
+
+uint32_t hantro_secure_open(struct tee_context* ctx, uint32_t id)
+{
+	const RTC_UUID pta_uuid = PTA_HANTRO_VPU_PTA_UUID;
+	struct tee_ioctl_open_session_arg sess_arg;
+	struct tee_param param[4];
+	struct tee_param *params = NULL;
+	int result;
+
+	if (ctx == NULL)
+		return 0;
+
+	memset(&sess_arg, 0, sizeof(sess_arg));
+	memset(&param, 0, sizeof(param));
+
+	/* Open session with pseudo TA */
+	uuid_to_octets(sess_arg.uuid, &pta_uuid);
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
+
+	if (id != 0xFFFFFFFF)
+	{
+		sess_arg.num_params = 4;
+
+		/* Fill invoke cmd params */
+		param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+		param[0].u.value.a = id;
+
+		params = param;
+	} else {
+		sess_arg.num_params = 0;
+	}
+
+	result = tee_client_open_session(ctx, &sess_arg, params);
+	if ((result < 0) || sess_arg.ret) {
+		pr_err("unable to open pta session 0x%08X\n",sess_arg.ret);
+		return 0;
+	}
+
+	return sess_arg.session;
+}
diff --git a/drivers/mxc/hantro_secure/hantrodec_secure.h b/drivers/mxc/hantro_secure/hantrodec_secure.h
new file mode 100644
index 00000000..983d937
--- /dev/null
+++ b/drivers/mxc/hantro_secure/hantrodec_secure.h
@@ -0,0 +1,44 @@
+/*****************************************************************************
+ *    The GPL License (GPL)
+ *
+ *    Copyright (c) 2019 NXP
+ *
+ *    This program is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU General Public License
+ *    as published by the Free Software Foundation; either version 2
+ *    of the License, or (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You may obtain a copy of the GNU General Public License
+ *    Version 2 or later at the following locations:
+ *    http://www.opensource.org/licenses/gpl-license.html
+ *    http://www.gnu.org/copyleft/gpl.html
+ *****************************************************************************/
+#include <linux/tee_drv.h>
+
+struct tee_shm *alloc_shm(struct tee_context *ctx, size_t size);
+
+void release_shm(struct tee_shm *shm);
+
+void hantro_secure_regs_write(struct tee_context *ctx, uint32_t session,
+		       uint32_t offset, uint32_t value);
+
+void hantro_hwregs_write_multiple(struct tee_context *ctx, struct tee_shm* shm, uint32_t session,
+		       uint32_t offset, void *regs, uint32_t size);
+
+uint32_t hantro_secure_regs_read(struct tee_context *ctx, uint32_t session,
+		       uint32_t offset);
+
+uint32_t hantro_secure_wait(struct tee_context *ctx, uint32_t session);
+
+struct tee_context* hantro_secure_open_context(void);
+
+uint32_t hantro_secure_open(struct tee_context *ctx, uint32_t id);
+
+int hantrodec_optee_match(struct tee_ioctl_version_data *ver,
+				const void *data);
+
-- 
2.7.4

